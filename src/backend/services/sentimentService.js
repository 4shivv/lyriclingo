const axios = require("axios");

// Use environment variable for HuggingFace API Token
const HUGGINGFACE_API_TOKEN = process.env.HUGGINGFACE_API_TOKEN;

// Configuration options
const MAX_RETRY_ATTEMPTS = 3;
const RETRY_DELAY_MS = 1000;
const MAX_TEXT_LENGTH = 1000; // Limit text to prevent large payloads

/**
 * Basic text-based sentiment analysis fallback when API is unavailable
 * This is a simple implementation that will run when the API is down
 * @param {string} text - Text to analyze
 * @returns {Object} Sentiment analysis result
 */
const localSentimentFallback = (text) => {
  console.log("üîÑ USING LOCAL FALLBACK SENTIMENT ANALYSIS");
  
  // Simple word-based sentiment analysis
  const positiveWords = [
    "good", "great", "excellent", "happy", "love", "joy", "wonderful", "amazing",
    "fantastic", "beautiful", "best", "positive", "awesome", "glad", "nice", "smile"
  ];
  
  const negativeWords = [
    "bad", "awful", "terrible", "sad", "hate", "unhappy", "angry", "disappointing",
    "worst", "negative", "horrible", "poor", "wrong", "pain", "cry", "sorry"
  ];
  
  const words = text.toLowerCase().match(/\b(\w+)\b/g) || [];
  
  let positiveCount = 0;
  let negativeCount = 0;
  
  words.forEach(word => {
    if (positiveWords.includes(word)) positiveCount++;
    if (negativeWords.includes(word)) negativeCount++;
  });
  
  let sentiment = "Neutral";
  let emoji = "üòê";
  let score = 0.5;
  
  if (positiveCount > negativeCount) {
    sentiment = positiveCount > negativeCount * 2 ? "Very Positive" : "Positive";
    emoji = positiveCount > positiveCount * 2 ? "üòÑ" : "üôÇ";
    score = 0.5 + (0.5 * (positiveCount / (positiveCount + negativeCount || 1)));
  } else if (negativeCount > positiveCount) {
    sentiment = negativeCount > positiveCount * 2 ? "Very Negative" : "Negative";
    emoji = negativeCount > positiveCount * 2 ? "üòû" : "üòï";
    score = 0.5 - (0.5 * (negativeCount / (positiveCount + negativeCount || 1)));
  }
  
  console.log(`‚úÖ LOCAL SENTIMENT ANALYSIS: ${sentiment} (Score: ${score.toFixed(2)})`);
  
  return {
    sentiment,
    emoji,
    score: score.toFixed(2),
    fallback: true, // Indicate this was generated by the fallback
    rawResults: null
  };
};

/**
 * Sleep function for implementing delay between retries
 * @param {number} ms - Milliseconds to sleep
 * @returns {Promise} Promise that resolves after the specified time
 */
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Analyze sentiment of text using HuggingFace API with retry logic and fallback
 * @param {string} text - Text to analyze
 * @returns {Object} Sentiment analysis result
 */
const analyzeSentiment = async (text) => {
  // Add token validation
  if (!HUGGINGFACE_API_TOKEN) {
    console.error("‚ùå HUGGINGFACE API: Token is not configured");
    return localSentimentFallback(text);
  }
  
  // Truncate text if it's too long to avoid large payloads
  const truncatedText = text.length > MAX_TEXT_LENGTH 
    ? text.substring(0, MAX_TEXT_LENGTH) + "..." 
    : text;
  
  // Retry logic implementation
  let attempts = 0;
  let lastError = null;
  
  while (attempts < MAX_RETRY_ATTEMPTS) {
    try {
      console.log(`üîç HUGGINGFACE API: Making request (attempt ${attempts + 1})...`);
      
      const response = await axios.post(
        "https://api-inference.huggingface.co/models/distilbert-base-uncased-finetuned-sst-2-english",
        { inputs: truncatedText },
        {
          headers: {
            Authorization: `Bearer ${HUGGINGFACE_API_TOKEN}`,
            "Content-Type": "application/json",
          },
          timeout: 10000, // 10 second timeout
        }
      );
      
      // Process and categorize sentiment
      if (response.data && response.data[0]) {
        // Get results and find the dominant sentiment
        const results = response.data[0];
        let dominantSentiment = { label: "NEUTRAL", score: 0 };
        
        for (const result of results) {
          if (result.score > dominantSentiment.score) {
            dominantSentiment = result;
          }
        }
        
        // Map the sentiment to a more user-friendly format
        let sentiment = "Neutral";
        let emoji = "üòê";
        
        if (dominantSentiment.label === "POSITIVE" && dominantSentiment.score > 0.7) {
          sentiment = "Very Positive";
          emoji = "üòÑ";
        } else if (dominantSentiment.label === "POSITIVE") {
          sentiment = "Positive";
          emoji = "üôÇ";
        } else if (dominantSentiment.label === "NEGATIVE" && dominantSentiment.score > 0.7) {
          sentiment = "Very Negative";
          emoji = "üòû";
        } else if (dominantSentiment.label === "NEGATIVE") {
          sentiment = "Negative";
          emoji = "üòï";
        }
        
        console.log(`‚úÖ HUGGINGFACE API: Sentiment analysis successful: ${sentiment} (Score: ${dominantSentiment.score.toFixed(2)})`);
        
        return {
          sentiment,
          emoji,
          score: dominantSentiment.score.toFixed(2),
          fallback: false,
          rawResults: results
        };
      }
      
      console.log("‚ö†Ô∏è HUGGINGFACE API: Received empty response, using neutral fallback");
      return { sentiment: "Neutral", emoji: "üòê", score: 0.5, fallback: false };
      
    } catch (error) {
      lastError = error;
      const statusCode = error.response?.status;
      attempts++;
      
      console.error(`‚ùå HUGGINGFACE API: Attempt ${attempts} failed with status ${statusCode}:`, 
        error.response?.data || error.message);
      
      // If we've reached max attempts or it's not a retryable error, break the loop
      if (attempts >= MAX_RETRY_ATTEMPTS || 
          (statusCode && ![429, 500, 502, 503, 504].includes(statusCode))) {
        break;
      }
      
      // Exponential backoff delay
      const delay = RETRY_DELAY_MS * Math.pow(2, attempts - 1);
      console.log(`‚è±Ô∏è HUGGINGFACE API: Retrying in ${delay}ms...`);
      await sleep(delay);
    }
  }
  
  console.error("‚ùå HUGGINGFACE API: All attempts failed, switching to local fallback");
  
  // If all retries fail, use the fallback sentiment analysis
  return localSentimentFallback(text);
};

module.exports = { analyzeSentiment };